# -*- coding: utf-8 -*-
"""k_nearest_neighbours.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vYHIDSBoTC3vvym2VNNFKxNPIoVlAYt9
"""

import numpy as np

class KNearestNeighbours:

  def euclideanDistance(self, instance1, instance2):
    ''' 'euclideanDistance' method takes two inputs instance1 and instance2 as arguments.
    Calculates and returns the square root value of sum of squares of differences between instances.'''
    distance = np.sqrt(np.sum((instance1 - instance2)**2, axis=1))
    return distance

  def fit(self, X_train, y_train):
    ''' 'fit' method takes X_train, y_train (Data to get neighbouring values) as arguments.'''
    self.X_train = X_train
    self.y_train = y_train

  def mode(self, my_list):
    ''' 'mode' method takes and my_list(list of elements) and returns most frequently occurred element.
    If multiple elements occur same number of times then smallest among them is returned.'''
    return list(max(my_list, key=my_list.count))

  def predict(self, X_test, k):
    ''' 'predict' method takes X_test(Test data), k(Numbers of neighbours to be considered).
    and returns predicted values.'''
    m, n = self.X_train.shape
    m1, n1 = X_test.shape

    # Initializing y_pred(list) to store predicted values.
    y_pred = []

    for i in range(len(X_test)):
      test_case = X_test[i,:]
      # Calculating distance between training set and test case.
      dist = self.euclideanDistance(self.X_train,test_case)
      # Stores indices of distance values in the increasing order of distance.
      sorted_dist_indices = np.argsort(dist)
      # Stores y values of k nearest neighbours as list.
      k_near_neighbours = list((self.y_train[sorted_dist_indices])[:k])
      # Finds most frequent neighbour and assigns its value as y_pred(predicted y).
      y_pred.append(self.mode(k_near_neighbours))

    y_pred = np.array(y_pred)    # Converting list to array
    return y_pred

  def accuracy(self, y_test, y_pred):
    ''' 'accuracy' method takes y_test(Real value), y_pred(Values predicted by algorithm)
    and returns accuracy of the algorithm on test data.'''
    accuracy = np.mean(y_pred==y_test)*100
    return accuracy

